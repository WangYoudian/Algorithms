思路是这样的：我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。

 

1. 如果此数据之前已经被缓存在链表中了，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部。

 

2. 如果此数据没有在缓存链表中，又可以分为两种情况：

　　如果此时缓存未满，则将此结点直接插入到链表的头部；

　　如果此时缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。+这样我们就用链表实现了一个+LRU+缓存，是不是很简单？

【思考与讨论】
其实，上述原理描述，和LRU算法的实现结构.jpg中实际采用的双向链表结构略微不同。前者描述时是用单链表，而后者是双向链表。联系一下在图论中学习的图的存储结构（邻接矩阵、邻接表、邻接多重表），有些类似邻接多重表的示意图。
只需要给LRUHashMap的节点加上一个mark标记，然后再对插入节点进行编号，二者就基本相同了。


此外，还有直接按照时间戳对节点进行更新的结构：
参考：https://gist.github.com/reterVision/5018901